"""Automatically add placeholder documentation to non-compliant functions"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_autofix.ipynb.

# %% auto 0
__all__ = ['find_signature_boundaries', 'split_parameters', 'parse_single_line_signature', 'generate_param_todo_comment',
           'generate_return_todo_comment', 'build_fixed_single_line_function', 'fix_multi_line_signature',
           'generate_fixed_source', 'fix_notebook']

# %% ../nbs/03_autofix.ipynb 3
from typing import List, Dict, Any, Optional
import re
from pathlib import Path
from execnb.nbio import read_nb, write_nb
from .core import DocmentsCheckResult, check_definition
from .scanner import scan_notebook, get_export_cells

# %% ../nbs/03_autofix.ipynb 4
def find_signature_boundaries(
    lines: List[str]  # Source code lines
) -> tuple[int, int]:  # (def_line_idx, sig_end_idx) or (-1, -1) if not found
    "Find the start and end lines of a function signature"
    def_line_idx = None
    sig_end_idx = None
    paren_count = 0
    in_signature = False
    
    for i, line in enumerate(lines):
        if line.strip().startswith(('def ', 'async def ')):
            def_line_idx = i
            in_signature = True
            
        if in_signature:
            # Count parentheses to find where signature ends
            paren_count += line.count('(') - line.count(')')
            
            # If we're back to balanced parens and line contains a colon, signature is done
            # (colon might be followed by comments)
            if paren_count == 0 and ':' in line:
                sig_end_idx = i
                break
    
    if def_line_idx is None or sig_end_idx is None:
        return -1, -1
    
    return def_line_idx, sig_end_idx

# %% ../nbs/03_autofix.ipynb 5
def split_parameters(
    params_str: str  # Parameter string from function signature
) -> List[str]:  # List of individual parameter strings
    "Split a parameter string into individual parameters, handling nested types"
    params = []
    current_param = ''
    paren_depth = 0
    
    for char in params_str:
        if char in '([{':
            paren_depth += 1
        elif char in ')]}':
            paren_depth -= 1
        elif char == ',' and paren_depth == 0:
            params.append(current_param.strip())
            current_param = ''
            continue
        current_param += char
    
    if current_param.strip():
        params.append(current_param.strip())
    
    return params

# %% ../nbs/03_autofix.ipynb 6
def parse_single_line_signature(
    sig_line: str  # Single-line function signature
) -> dict:  # Parsed components of the signature
    "Parse a single-line function signature into its components"
    func_match = re.match(r'^(\s*)(def|async def)\s+(\w+)\s*\((.*?)\)(\s*(?:->\s*[^:]+)?)\s*:\s*(.*)$', sig_line)
    if not func_match:
        return None
    
    return {
        'indent': func_match.group(1),
        'def_keyword': func_match.group(2),
        'func_name': func_match.group(3),
        'params_str': func_match.group(4),
        'return_type': func_match.group(5),
        'existing_comment': func_match.group(6).strip()
    }

# %% ../nbs/03_autofix.ipynb 7
def generate_param_todo_comment(
    param_name: str,  # Parameter name
    result: DocmentsCheckResult,  # Check result with type hint and doc info
    existing_comment: str = ""  # Existing comment text (without #)
) -> str:  # TODO comment to add
    "Generate appropriate TODO comment for a parameter based on what's missing"
    has_type_hint = result.params_with_type_hints.get(param_name, False)
    has_doc = result.params_documented.get(param_name, False)
    
    if not has_type_hint and not has_doc:
        # Missing both type hint and description
        return "TODO: Add type hint and description"
    elif not has_type_hint and has_doc:
        # Has description but missing type hint
        if existing_comment:
            # Check if TODO for type hint already exists
            if "TODO: Add type hint" in existing_comment or "TODO:Add type hint" in existing_comment:
                return existing_comment  # Don't add duplicate TODO
            else:
                return f"{existing_comment} - TODO: Add type hint"
        else:
            return "TODO: Add type hint"
    elif has_type_hint and not has_doc:
        # Has type hint but missing description
        return "TODO: Add description"
    else:
        # This shouldn't happen if we're being asked to generate a comment
        return existing_comment if existing_comment else "TODO: Verify documentation"


#| export
def generate_return_todo_comment(
    result: DocmentsCheckResult,  # Check result with type hint and doc info
    existing_comment: str = ""  # Existing comment text (without #)
) -> str:  # TODO comment to add
    "Generate appropriate TODO comment for return value based on what's missing"
    has_type_hint = result.return_has_type_hint
    has_doc = result.return_documented
    
    if not has_type_hint and not has_doc:
        # Missing both type hint and description
        return "TODO: Add type hint and return description"
    elif not has_type_hint and has_doc:
        # Has description but missing type hint
        if existing_comment:
            # Check if TODO for type hint already exists
            if "TODO: Add type hint" in existing_comment or "TODO:Add type hint" in existing_comment:
                return existing_comment  # Don't add duplicate TODO
            else:
                return f"{existing_comment} - TODO: Add type hint"
        else:
            return "TODO: Add type hint"
    elif has_type_hint and not has_doc:
        # Has type hint but missing description
        return "TODO: Add return description"
    else:
        # This shouldn't happen if we're being asked to generate a comment
        return existing_comment if existing_comment else "TODO: Verify description"


#| export
def build_fixed_single_line_function(
    parsed: dict,  # Parsed signature components
    params: List[str],  # Individual parameter strings
    result: DocmentsCheckResult  # Check result with missing params info
) -> List[str]:  # Lines of fixed function signature
    "Build a fixed single-line function with documentation comments"
    fixed_lines = []
    indent = parsed['indent']
    
    # Start the function definition
    fixed_lines.append(f"{indent}{parsed['def_keyword']} {parsed['func_name']}(")
    
    # Add parameters with comments as needed
    for i, param in enumerate(params):
        # Check if this parameter needs documentation or type hints
        param_name = param.split(':', 1)[0].split('=', 1)[0].strip()
        
        needs_doc_fix = param_name in result.missing_params and param_name != 'self'
        needs_type_hint_fix = param_name in result.params_missing_type_hints and param_name != 'self'
        
        if needs_doc_fix or needs_type_hint_fix:
            todo_comment = generate_param_todo_comment(param_name, result)
            if i < len(params) - 1:
                fixed_lines.append(f"{indent}    {param},  # {todo_comment}")
            else:
                fixed_lines.append(f"{indent}    {param}  # {todo_comment}")
        else:
            if i < len(params) - 1:
                fixed_lines.append(f"{indent}    {param},")
            else:
                fixed_lines.append(f"{indent}    {param}")
    
    # Handle return type and existing comment
    return_type = parsed['return_type']
    existing_comment = parsed['existing_comment']
    
    # For single-line conversions, check if return needs fixing
    if return_type:
        if 'return' in result.missing_params or 'return' in result.params_missing_type_hints:
            if existing_comment:
                # Parse existing comment
                comment_text = existing_comment[1:].strip() if existing_comment.startswith('#') else existing_comment
                todo_comment = generate_return_todo_comment(result, comment_text)
                fixed_lines.append(f"{indent}){return_type}: # {todo_comment}")
            else:
                # No existing comment
                todo_comment = generate_return_todo_comment(result)
                fixed_lines.append(f"{indent}){return_type}:  # {todo_comment}")
        else:
            # Return doesn't need fixing
            if existing_comment:
                if existing_comment.startswith('#'):
                    fixed_lines.append(f"{indent}){return_type}: {existing_comment}")
                else:
                    fixed_lines.append(f"{indent}){return_type}: # {existing_comment}")
            else:
                fixed_lines.append(f"{indent}){return_type}:")
    else:
        # No return type but might need one
        if 'return' in result.params_missing_type_hints:
            if existing_comment:
                comment_text = existing_comment[1:].strip() if existing_comment.startswith('#') else existing_comment
                todo_comment = generate_return_todo_comment(result, comment_text)
                fixed_lines.append(f"{indent}): # {todo_comment}")
            else:
                todo_comment = generate_return_todo_comment(result)
                fixed_lines.append(f"{indent}): # {todo_comment}")
        else:
            # No return type needed
            if existing_comment:
                if existing_comment.startswith('#'):
                    fixed_lines.append(f"{indent}): {existing_comment}")
                else:
                    fixed_lines.append(f"{indent}): # {existing_comment}")
            else:
                fixed_lines.append(f"{indent}):")
    
    return fixed_lines

# %% ../nbs/03_autofix.ipynb 8
def fix_multi_line_signature(
    lines: List[str],  # All source lines
    def_line_idx: int,  # Start of function definition
    sig_end_idx: int,  # End of function signature
    result: DocmentsCheckResult  # Check result with missing params info
) -> List[str]:  # Fixed lines for the signature portion
    "Fix a multi-line function signature by adding parameter comments"
    fixed_lines = []
    
    for i in range(def_line_idx, sig_end_idx + 1):
        line = lines[i]
        line_stripped = line.strip()
        
        # More flexible parameter matching for multi-line signatures
        # Match: whitespace + word + optional type annotation + optional comma/paren + optional whitespace + optional comment
        param_match = re.match(r'^(\s*)(\w+)(\s*(?::\s*[^,\)#]+)?)\s*([,\)]?)(\s*)(?:#\s*(.*))?$', line)
        if param_match and i > def_line_idx and i < sig_end_idx:
            # This is a parameter line (not the def line, not the return line)
            indent = param_match.group(1)
            param_name = param_match.group(2)
            type_annotation = param_match.group(3) or ''
            trailing_punct = param_match.group(4) or ''
            trailing_space = param_match.group(5) or ''
            existing_comment = param_match.group(6) or ''
            
            # Check if this parameter needs fixing (either missing docs or missing type hints)
            needs_doc_fix = param_name in result.missing_params and param_name != 'self'
            needs_type_hint_fix = param_name in result.params_missing_type_hints and param_name != 'self'
            
            if needs_doc_fix or needs_type_hint_fix:
                todo_comment = generate_param_todo_comment(param_name, result, existing_comment)
                # Only add the fixed line if the comment actually changed
                if todo_comment != existing_comment:
                    fixed_lines.append(f"{indent}{param_name}{type_annotation}{trailing_punct}{trailing_space}  # {todo_comment}")
                else:
                    # Comment didn't change, keep original line
                    fixed_lines.append(line)
            else:
                fixed_lines.append(line)
        else:
            # Check for return type line
            return_match = re.match(r'^(\s*\)\s*->\s*[^:#]+)\s*:\s*(.*)$', line)
            if return_match and ('return' in result.missing_params or 'return' in result.params_missing_type_hints):
                pre_colon = return_match.group(1)
                after_colon = return_match.group(2).strip()
                
                if after_colon:
                    # There's already a comment, generate appropriate TODO
                    comment_text = after_colon[1:].strip() if after_colon.startswith('#') else after_colon
                    todo_comment = generate_return_todo_comment(result, comment_text)
                    # Only change if the comment actually changed
                    if todo_comment != comment_text:
                        fixed_lines.append(f"{pre_colon}: # {todo_comment}")
                    else:
                        fixed_lines.append(line)
                else:
                    # No comment, add full TODO
                    todo_comment = generate_return_todo_comment(result)
                    fixed_lines.append(f"{pre_colon}:  # {todo_comment}")
            else:
                fixed_lines.append(line)
    
    return fixed_lines

# %% ../nbs/03_autofix.ipynb 9
def generate_fixed_source(
    result: DocmentsCheckResult  # Check result with non-compliant function
) -> str:  # Fixed source code with placeholder documentation
    "Generate fixed source code for a non-compliant function or class"
    lines = result.source.split('\n')
    fixed_lines = []
    
    # Handle classes (including dataclasses)
    if result.type == 'ClassDef':
        # Find the class definition line
        class_line_idx = -1
        for i, line in enumerate(lines):
            if line.strip().startswith('class '):
                class_line_idx = i
                break
        
        if class_line_idx == -1:
            return result.source
        
        # Add lines up to and including the class definition
        for i in range(class_line_idx + 1):
            fixed_lines.append(lines[i])
        
        # If missing docstring, add it after the class definition
        if not result.has_docstring:
            # Find the indentation of the first line after class definition
            indent = ''
            if class_line_idx + 1 < len(lines):
                next_line = lines[class_line_idx + 1]
                # Match leading whitespace
                indent_match = re.match(r'^(\s*)', next_line)
                if indent_match:
                    indent = indent_match.group(1)
                else:
                    # Default to 4 spaces if can't determine
                    indent = '    '
            else:
                indent = '    '
            
            fixed_lines.append(f'{indent}"TODO: Add class description"')
        
        # Add the rest of the class body
        for i in range(class_line_idx + 1, len(lines)):
            fixed_lines.append(lines[i])
        
        return '\n'.join(fixed_lines)
    
    # Function handling - check if we need to fix anything
    needs_fixing = (not result.is_compliant or 
                   result.missing_params or 
                   result.params_missing_type_hints)
    
    if not needs_fixing:
        return result.source
    
    # Find the function definition line and signature end
    def_line_idx, sig_end_idx = find_signature_boundaries(lines)
    
    if def_line_idx == -1:
        return result.source
    
    # For single-line signatures, we need to split and reformat
    if def_line_idx == sig_end_idx and (result.missing_params or result.params_missing_type_hints):
        # Parse the signature
        parsed = parse_single_line_signature(lines[def_line_idx])
        if not parsed:
            return result.source
        
        # Split parameters
        params = split_parameters(parsed['params_str'])
        
        # Build the fixed function
        fixed_lines = build_fixed_single_line_function(parsed, params, result)
        
        # Add docstring if missing
        if not result.has_docstring:
            fixed_lines.append(f'{parsed["indent"]}    "TODO: Add function description"')
        
        # Add rest of function body
        for i in range(sig_end_idx + 1, len(lines)):
            fixed_lines.append(lines[i])
    else:
        # Multi-line signature - process line by line
        # Add lines before the function
        for i in range(def_line_idx):
            fixed_lines.append(lines[i])
        
        # Fix the signature
        signature_lines = fix_multi_line_signature(lines, def_line_idx, sig_end_idx, result)
        fixed_lines.extend(signature_lines)
        
        # Insert docstring immediately after signature ends if missing
        if not result.has_docstring:
            # Find the indentation of the function definition
            indent_match = re.match(r'^(\s*)', lines[def_line_idx])
            base_indent = indent_match.group(1) if indent_match else ''
            docstring_indent = base_indent + '    '
            fixed_lines.append(f'{docstring_indent}"TODO: Add function description"')
        
        # Add rest of function body
        for i in range(sig_end_idx + 1, len(lines)):
            fixed_lines.append(lines[i])
    
    return '\n'.join(fixed_lines)

# %% ../nbs/03_autofix.ipynb 10
def fix_notebook(
    nb_path: Path,  # Path to notebook to fix
    dry_run: bool = False  # If True, show changes without saving
) -> Dict[str, Any]:  # Summary of changes made
    "Fix non-compliant functions in a notebook by adding placeholder documentation"
    nb = read_nb(nb_path)
    definitions = scan_notebook(nb_path)
    
    changes = {
        'notebook': nb_path.name,
        'definitions_fixed': [],
        'cells_modified': []
    }
    
    # Check each definition
    for defn in definitions:
        result = check_definition(defn)
        
        # Fix if non-compliant OR has missing type hints
        needs_fixing = (not result.is_compliant or 
                       result.missing_params or 
                       result.params_missing_type_hints)
        
        if needs_fixing:
            # Generate fixed source
            fixed_source = generate_fixed_source(result)
            
            # Only proceed if the source actually changed
            if fixed_source != result.source:
                # Find and update the cell
                cell_id = defn['cell_id']
                for cell in nb.cells:
                    if cell.get('id') == cell_id:
                        # Replace the definition in the cell source
                        old_source = result.source
                        cell_source = cell.source
                        
                        # Find the definition in the cell and replace it
                        if old_source in cell_source:
                            new_cell_source = cell_source.replace(old_source, fixed_source)
                            
                            if not dry_run:
                                cell.source = new_cell_source
                            
                            changes['definitions_fixed'].append(result.name)
                            if cell_id not in changes['cells_modified']:
                                changes['cells_modified'].append(cell_id)
                            
                            if dry_run:
                                print(f"\nWould fix {result.name}:")
                                print("-" * 40)
                                print(fixed_source)
                                print("-" * 40)
    
    # Save the notebook if not dry run
    if not dry_run and changes['definitions_fixed']:
        write_nb(nb, nb_path)
        # Fix grammar: use singular/plural based on count
        count = len(changes['definitions_fixed'])
        item_word = "definition" if count == 1 else "definitions"
        print(f"‚úÖ Fixed {count} {item_word} in {nb_path.name}")
        for defn_name in changes['definitions_fixed']:
            print(f"   - {defn_name}")
    elif dry_run and changes['definitions_fixed']:
        count = len(changes['definitions_fixed'])
        item_word = "definition" if count == 1 else "definitions" 
        print(f"\nüîç Dry run: Would fix {count} {item_word}")
    else:
        print(f"‚úÖ All definitions in {nb_path.name} are already compliant")
    
    return changes
