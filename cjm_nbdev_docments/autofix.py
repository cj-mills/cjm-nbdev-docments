"""Automatically add placeholder documentation to non-compliant functions"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_autofix.ipynb.

# %% auto 0
__all__ = ['generate_fixed_source', 'fix_notebook']

# %% ../nbs/03_autofix.ipynb 3
from typing import List, Dict, Any, Optional
import re
from pathlib import Path
from execnb.nbio import read_nb, write_nb
from .core import DocmentsCheckResult, check_definition
from .scanner import scan_notebook, get_export_cells

# %% ../nbs/03_autofix.ipynb 4
def generate_fixed_source(
    result: DocmentsCheckResult  # Check result with non-compliant function
) -> str:  # Fixed source code with placeholder documentation
    "Generate fixed source code for a non-compliant function"
    lines = result.source.split('\n')
    fixed_lines = []
    
    # Find the function definition line and signature end
    def_line_idx = None
    sig_end_idx = None
    paren_count = 0
    in_signature = False
    
    for i, line in enumerate(lines):
        if line.strip().startswith(('def ', 'async def ')):
            def_line_idx = i
            in_signature = True
            
        if in_signature:
            # Count parentheses to find where signature ends
            paren_count += line.count('(') - line.count(')')
            
            # If we're back to balanced parens and line contains a colon, signature is done
            # (colon might be followed by comments)
            if paren_count == 0 and ':' in line:
                sig_end_idx = i
                break
    
    if def_line_idx is None or sig_end_idx is None:
        return result.source
    
    # For single-line signatures, we need to split and reformat
    if def_line_idx == sig_end_idx and result.missing_params:
        # Extract the signature
        sig_line = lines[def_line_idx]
        
        # Parse function name and parameters, and capture any existing comment
        func_match = re.match(r'^(\s*)(def|async def)\s+(\w+)\s*\((.*?)\)(\s*(?:->\s*[^:]+)?)\s*:\s*(.*)$', sig_line)
        if func_match:
            indent = func_match.group(1)
            def_keyword = func_match.group(2)
            func_name = func_match.group(3)
            params_str = func_match.group(4)
            return_type = func_match.group(5)
            existing_comment = func_match.group(6).strip()
            
            # Split parameters
            params = []
            current_param = ''
            paren_depth = 0
            
            for char in params_str:
                if char in '([{':
                    paren_depth += 1
                elif char in ')]}':
                    paren_depth -= 1
                elif char == ',' and paren_depth == 0:
                    params.append(current_param.strip())
                    current_param = ''
                    continue
                current_param += char
            
            if current_param.strip():
                params.append(current_param.strip())
            
            # Rebuild function with multi-line params if needed
            fixed_lines.append(f"{indent}{def_keyword} {func_name}(")
            
            for i, param in enumerate(params):
                # Check if this parameter needs documentation
                param_name = param.split(':', 1)[0].split('=', 1)[0].strip()
                
                if param_name in result.missing_params and param_name != 'self':
                    if i < len(params) - 1:
                        fixed_lines.append(f"{indent}    {param},  # TODO: Add description")
                    else:
                        fixed_lines.append(f"{indent}    {param}  # TODO: Add description")
                else:
                    if i < len(params) - 1:
                        fixed_lines.append(f"{indent}    {param},")
                    else:
                        fixed_lines.append(f"{indent}    {param}")
            
            # Handle return type and existing comment
            # For single-line conversions, ALWAYS add verification TODO if there's an existing comment
            if return_type:
                if existing_comment:
                    # Always preserve existing comment but add TODO for verification
                    # because we don't know if it was actually for the return value
                    if existing_comment.startswith('#'):
                        # Remove the # and any leading spaces
                        comment_text = existing_comment[1:].strip()
                        fixed_lines.append(f"{indent}){return_type}: # {comment_text} - TODO: Verify description")
                    else:
                        # Comment without #, add it
                        fixed_lines.append(f"{indent}){return_type}: # {existing_comment} - TODO: Verify description")
                else:
                    # No existing comment
                    if 'return' in result.missing_params:
                        fixed_lines.append(f"{indent}){return_type}:  # TODO: Add return description")
                    else:
                        fixed_lines.append(f"{indent}){return_type}:")
            else:
                # No return type
                if existing_comment:
                    if existing_comment.startswith('#'):
                        fixed_lines.append(f"{indent}): {existing_comment}")
                    else:
                        fixed_lines.append(f"{indent}): # {existing_comment}")
                else:
                    fixed_lines.append(f"{indent}):")
                
            # Add docstring if missing
            if not result.has_docstring:
                fixed_lines.append(f'{indent}    "TODO: Add function description"')
                
            # Add rest of function body
            for i in range(sig_end_idx + 1, len(lines)):
                fixed_lines.append(lines[i])
        else:
            # Fallback to original if parsing fails
            return result.source
    else:
        # Multi-line signature - process line by line
        for i, line in enumerate(lines):
            if i < def_line_idx:
                # Before function definition
                fixed_lines.append(line)
            elif i >= def_line_idx and i <= sig_end_idx:
                # Function signature lines - improved parameter detection
                line_stripped = line.strip()
                
                # More flexible parameter matching for multi-line signatures
                # Match: whitespace + word + optional type annotation + optional comma/paren + optional whitespace
                param_match = re.match(r'^(\s*)(\w+)(\s*:\s*[^,\)#]*)?(\s*,?\s*)$', line)
                if param_match and i > def_line_idx and i < sig_end_idx:
                    # This is a parameter line (not the def line, not the return line)
                    indent = param_match.group(1)
                    param_name = param_match.group(2)
                    type_annotation = param_match.group(3) or ''
                    trailing = param_match.group(4) or ''
                    
                    if param_name in result.missing_params and param_name != 'self':
                        fixed_lines.append(f"{indent}{param_name}{type_annotation}{trailing}  # TODO: Add description")
                    else:
                        fixed_lines.append(line)
                else:
                    # Check for return type line
                    return_match = re.match(r'^(\s*\)\s*->\s*[^:#]+)\s*:\s*(.*)$', line)
                    if return_match and 'return' in result.missing_params:
                        pre_colon = return_match.group(1)
                        after_colon = return_match.group(2).strip()
                        if after_colon:
                            # There's already a comment, preserve it with TODO
                            if after_colon.startswith('#'):
                                comment_text = after_colon[1:].strip()
                                fixed_lines.append(f"{pre_colon}: # {comment_text} - TODO: Verify description")
                            else:
                                fixed_lines.append(f"{pre_colon}: # {after_colon} - TODO: Verify description")
                        else:
                            # No comment, add full TODO
                            fixed_lines.append(f"{pre_colon}:  # TODO: Add return description")
                    else:
                        fixed_lines.append(line)
                
                # Insert docstring immediately after signature ends
                if i == sig_end_idx and not result.has_docstring:
                    # Find the indentation of the function definition
                    indent_match = re.match(r'^(\s*)', lines[def_line_idx])
                    base_indent = indent_match.group(1) if indent_match else ''
                    docstring_indent = base_indent + '    '
                    fixed_lines.append(f'{docstring_indent}"TODO: Add function description"')
            else:
                # Function body - just copy remaining lines
                fixed_lines.append(line)
    
    return '\n'.join(fixed_lines)

# %% ../nbs/03_autofix.ipynb 5
def fix_notebook(
    nb_path: Path,  # Path to notebook to fix
    dry_run: bool = False  # If True, show changes without saving
) -> Dict[str, Any]:  # Summary of changes made
    "Fix non-compliant functions in a notebook by adding placeholder documentation"
    nb = read_nb(nb_path)
    definitions = scan_notebook(nb_path)
    
    changes = {
        'notebook': nb_path.name,
        'functions_fixed': [],
        'cells_modified': []
    }
    
    # Check each definition
    for defn in definitions:
        result = check_definition(defn)
        
        if not result.is_compliant:
            # Generate fixed source
            fixed_source = generate_fixed_source(result)
            
            # Find and update the cell
            cell_id = defn['cell_id']
            for cell in nb.cells:
                if cell.get('id') == cell_id:
                    # Replace the function in the cell source
                    old_source = result.source
                    cell_source = cell.source
                    
                    # Find the function in the cell and replace it
                    if old_source in cell_source:
                        new_cell_source = cell_source.replace(old_source, fixed_source)
                        
                        if not dry_run:
                            cell.source = new_cell_source
                        
                        changes['functions_fixed'].append(result.name)
                        if cell_id not in changes['cells_modified']:
                            changes['cells_modified'].append(cell_id)
                        
                        if dry_run:
                            print(f"\nWould fix {result.name}:")
                            print("-" * 40)
                            print(fixed_source)
                            print("-" * 40)
    
    # Save the notebook if not dry run
    if not dry_run and changes['functions_fixed']:
        write_nb(nb, nb_path)
        print(f"✅ Fixed {len(changes['functions_fixed'])} functions in {nb_path.name}")
        for func in changes['functions_fixed']:
            print(f"   - {func}")
    elif dry_run and changes['functions_fixed']:
        print(f"\n🔍 Dry run: Would fix {len(changes['functions_fixed'])} functions")
    else:
        print(f"✅ All functions in {nb_path.name} are already compliant")
    
    return changes
