"""Core functionality for checking docments compliance"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['DocmentsCheckResult', 'extract_param_docs', 'check_return_doc', 'check_definition', 'check_notebook',
           'check_function']

# %% ../nbs/00_core.ipynb 3
from typing import Dict, List, Any, Optional, Tuple
import re
import ast
from dataclasses import dataclass

# %% ../nbs/00_core.ipynb 4
@dataclass
class DocmentsCheckResult:
    "Result of checking a function/class for docments compliance"
    name: str  # Name of the function/class
    type: str  # Type (FunctionDef, ClassDef, etc.)
    notebook: str  # Source notebook
    has_docstring: bool  # Whether it has a docstring
    params_documented: Dict[str, bool]  # Which params have documentation
    return_documented: bool  # Whether return is documented
    missing_params: List[str]  # Parameters missing documentation
    is_compliant: bool  # Overall compliance status
    source: str  # Source code of the definition
    has_todos: bool = False  # Whether it contains TODO placeholders
    todo_count: int = 0  # Number of TODO placeholders found

# %% ../nbs/00_core.ipynb 5
def extract_param_docs(
    source: str  # Function source code
) -> Dict[str, str]:  # Mapping of parameter names to their documentation
    "Extract parameter documentation from function source using docments style"
    param_docs = {}
    lines = source.split('\n')
    in_params = False
    
    for i, line in enumerate(lines):
        stripped = line.strip()
        
        # Start looking after def line
        if stripped.startswith(('def ', 'async def ')):
            in_params = True
            continue
            
        # Stop when we hit the docstring
        if in_params and stripped.startswith(('"', "'", '"""', "'''")):
            break
            
        # Skip if not in parameters section
        if not in_params:
            continue
            
        # Match parameter with inline comment
        # More flexible regex that handles various spacing
        param_match = re.match(r'\s*(\w+)(?:\s*:\s*[^#]+)?\s*#\s*(.+)', line)
        if param_match:
            param_name = param_match.group(1)
            param_doc = param_match.group(2).strip()
            param_docs[param_name] = param_doc
    
    return param_docs

# %% ../nbs/00_core.ipynb 6
def check_return_doc(
    source: str  # Function source code
) -> bool:  # Whether return is documented
    "Check if function has return documentation"
    lines = source.split('\n')
    
    for line in lines:
        # Check for return type annotation with comment
        if re.search(r'->\s*[^:]+\s*:\s*#\s*.+', line):
            return True
        # Check for standalone return comment
        if re.match(r'\s*->\s*[^:]+\s*$', line):
            # Check if next line has a comment
            idx = lines.index(line)
            if idx + 1 < len(lines):
                next_line = lines[idx + 1]
                if re.match(r'\s*#\s*.+', next_line):
                    return True
    
    return False

# %% ../nbs/00_core.ipynb 7
def check_definition(
    definition: Dict[str, Any]  # Definition dict from scanner
) -> DocmentsCheckResult:  # Check result with compliance details
    "Check a function/class definition for docments compliance"
    name = definition['name']
    def_type = definition['type']
    source = definition['source']
    notebook = definition.get('notebook', 'unknown')
    
    # Check for TODO placeholders only in documentation
    todo_count = 0
    has_todos = False
    
    # Count TODOs in parameter comments (only in docments-style parameter docs)
    param_docs = extract_param_docs(source)
    for doc in param_docs.values():
        todo_count += doc.count('TODO:')
    
    # Count TODOs in return type comments (only inline after return type)
    lines = source.split('\n')
    for line in lines:
        # Check for return type comment - must be return annotation followed by comment
        return_comment_match = re.search(r'\)\s*->\s*[^:#]+\s*:\s*#\s*(.*)', line)
        if return_comment_match:
            comment_text = return_comment_match.group(1)
            todo_count += comment_text.count('TODO:')
    
    # Count TODOs in docstring only
    try:
        tree = ast.parse(source)
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
                if node.name == name and node.body:
                    # Check if first statement is a docstring
                    first_stmt = node.body[0]
                    if (isinstance(first_stmt, ast.Expr) and 
                        isinstance(first_stmt.value, (ast.Str, ast.Constant))):
                        if hasattr(first_stmt.value, 's'):
                            docstring = first_stmt.value.s
                        elif hasattr(first_stmt.value, 'value'):
                            docstring = first_stmt.value.value
                        else:
                            docstring = ""
                        
                        if isinstance(docstring, str):
                            todo_count += docstring.count('TODO:')
                    break
    except:
        pass
    
    has_todos = todo_count > 0
    
    # Check for docstring using AST parsing
    has_docstring = False
    try:
        tree = ast.parse(source)
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
                if node.name == name:
                    # Check if first statement in body is a string (docstring)
                    if (node.body and 
                        isinstance(node.body[0], ast.Expr) and 
                        isinstance(node.body[0].value, (ast.Str, ast.Constant))):
                        has_docstring = True
                    break
    except:
        # Fallback to simple string detection
        has_docstring = any(line.strip().startswith(('"', "'")) for line in source.split('\n')[1:5])
    
    # Initialize results
    params_documented = {}
    missing_params = []
    return_documented = True  # Default for classes
    
    # For functions, check parameters and return
    if def_type in ['FunctionDef', 'AsyncFunctionDef']:
        # Check each parameter
        for arg in definition.get('args', []):
            param_name = arg['name']
            if param_name != 'self':  # Skip self parameter
                has_doc = param_name in param_docs
                params_documented[param_name] = has_doc
                if not has_doc:
                    missing_params.append(param_name)
        
        # Check return documentation if function has return annotation
        if definition.get('returns'):
            return_documented = check_return_doc(source)
            if not return_documented:
                missing_params.append('return')
    
    # Determine overall compliance (compliant if documented but may have TODOs)
    is_compliant = (
        has_docstring and 
        all(params_documented.values()) and 
        return_documented
    )
    
    return DocmentsCheckResult(
        name=name,
        type=def_type,
        notebook=notebook,
        has_docstring=has_docstring,
        params_documented=params_documented,
        return_documented=return_documented,
        missing_params=missing_params,
        is_compliant=is_compliant,
        source=source,
        has_todos=has_todos,
        todo_count=todo_count
    )

# %% ../nbs/00_core.ipynb 8
def check_notebook(
    nb_path: str  # Path to notebook file  
) -> None:  # Prints compliance report
    "Check a specific notebook for docments compliance"
    from pathlib import Path
    from cjm_nbdev_docments.scanner import scan_notebook
    from cjm_nbdev_docments.report import generate_text_report
    
    nb_path = Path(nb_path)
    definitions = scan_notebook(nb_path)
    results = [check_definition(defn) for defn in definitions]
    
    print(f"Checking {nb_path.name}:")
    print(generate_text_report(results, verbose=True))

# %% ../nbs/00_core.ipynb 9
def check_function(
    func  # Function object to check
) -> DocmentsCheckResult:  # Check result for the function
    "Check a single function for docments compliance"
    import inspect
    
    # Get function source
    source = inspect.getsource(func)
    
    # Create a definition dict compatible with check_definition
    definition = {
        'name': func.__name__,
        'type': 'FunctionDef',
        'source': source,
        'notebook': 'runtime',
        'args': []
    }
    
    # Extract arguments
    sig = inspect.signature(func)
    for param_name, param in sig.parameters.items():
        if param_name != 'self':
            definition['args'].append({
                'name': param_name,
                'annotation': str(param.annotation) if param.annotation != param.empty else None
            })
    
    # Check for return annotation
    if sig.return_annotation != sig.empty:
        definition['returns'] = str(sig.return_annotation)
    
    result = check_definition(definition)
    
    # Print a simple report
    if result.is_compliant:
        print(f"✅ {result.name} is compliant")
    else:
        print(f"❌ {result.name} is not compliant")
        if not result.has_docstring:
            print("   - Missing docstring")
        if result.missing_params:
            print(f"   - Missing docs for: {', '.join(result.missing_params)}")
    
    return result
