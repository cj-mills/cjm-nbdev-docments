# Auto-Fix


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

------------------------------------------------------------------------

### DocmentsCheckResult.needs_fixing

>  DocmentsCheckResult.needs_fixing ()

*Check if this definition needs any fixing*

------------------------------------------------------------------------

### DocmentsCheckResult.get_param_name

>  DocmentsCheckResult.get_param_name (param_str:str)

*Extract parameter name from a parameter string*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>param_str</td>
<td>str</td>
<td>Parameter string (e.g., ‚Äúx: int‚Äù or ‚Äúy=10‚Äù)</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>str</strong></td>
<td><strong>Extracted parameter name</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### DocmentsCheckResult.needs_param_fix

>  DocmentsCheckResult.needs_param_fix (param_name:str)

*Check if a parameter needs documentation or type hint fixes*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>param_name</td>
<td>str</td>
<td>Name of the parameter to check</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>bool</strong></td>
<td><strong>Whether the parameter needs fixing</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### find_signature_boundaries

>  find_signature_boundaries (lines:List[str])

*Find the start and end lines of a function signature*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>lines</td>
<td>List</td>
<td>Source code lines</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>tuple</strong></td>
<td><strong>(def_line_idx, sig_end_idx) or (-1, -1) if not
found</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### split_parameters

>  split_parameters (params_str:str)

*Split a parameter string into individual parameters, handling nested
types*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>params_str</td>
<td>str</td>
<td>Parameter string from function signature</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>List</strong></td>
<td><strong>List of individual parameter strings</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### parse_single_line_signature

>  parse_single_line_signature (sig_line:str)

*Parse a single-line function signature into its components*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>sig_line</td>
<td>str</td>
<td>Single-line function signature</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>dict</strong></td>
<td><strong>Parsed components of the signature</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### generate_param_todo_comment

>  generate_param_todo_comment (param_name:str,
>                                   result:cjm_nbdev_docments.core.DocmentsCheck
>                                   Result, existing_comment:str='')

*Generate appropriate TODO comment for a parameter based on what‚Äôs
missing*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>param_name</td>
<td>str</td>
<td></td>
<td>Parameter name</td>
</tr>
<tr>
<td>result</td>
<td>DocmentsCheckResult</td>
<td></td>
<td>Check result with type hint and doc info</td>
</tr>
<tr>
<td>existing_comment</td>
<td>str</td>
<td></td>
<td>Existing comment text (without #)</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>str</strong></td>
<td></td>
<td><strong>TODO comment to add</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### generate_return_todo_comment

>  generate_return_todo_comment
>                                    (result:cjm_nbdev_docments.core.DocmentsChe
>                                    ckResult, existing_comment:str='')

*Generate appropriate TODO comment for return value based on what‚Äôs
missing*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>result</td>
<td>DocmentsCheckResult</td>
<td></td>
<td>Check result with type hint and doc info</td>
</tr>
<tr>
<td>existing_comment</td>
<td>str</td>
<td></td>
<td>Existing comment text (without #)</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>str</strong></td>
<td></td>
<td><strong>TODO comment to add</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### build_fixed_single_line_function

>  build_fixed_single_line_function (parsed:dict, params:List[str],
>                                        result:cjm_nbdev_docments.core.Docments
>                                        CheckResult)

*Build a fixed single-line function with documentation comments*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>parsed</td>
<td>dict</td>
<td>Parsed signature components</td>
</tr>
<tr>
<td>params</td>
<td>List</td>
<td>Individual parameter strings</td>
</tr>
<tr>
<td>result</td>
<td>DocmentsCheckResult</td>
<td>Check result with missing params info</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>List</strong></td>
<td><strong>Lines of fixed function signature</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### fix_multi_line_signature

>  fix_multi_line_signature (lines:List[str], def_line_idx:int,
>                                sig_end_idx:int, result:cjm_nbdev_docments.core
>                                .DocmentsCheckResult)

*Fix a multi-line function signature by adding parameter comments*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>lines</td>
<td>List</td>
<td>All source lines</td>
</tr>
<tr>
<td>def_line_idx</td>
<td>int</td>
<td>Start of function definition</td>
</tr>
<tr>
<td>sig_end_idx</td>
<td>int</td>
<td>End of function signature</td>
</tr>
<tr>
<td>result</td>
<td>DocmentsCheckResult</td>
<td>Check result with missing params info</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>List</strong></td>
<td><strong>Fixed lines for the signature portion</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### fix_class_definition

>  fix_class_definition (result:cjm_nbdev_docments.core.DocmentsCheckResult)

*Fix a class definition by adding a docstring if missing*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>result</td>
<td>DocmentsCheckResult</td>
<td>Check result with non-compliant class</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>str</strong></td>
<td><strong>Fixed source code with class docstring</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### insert_function_docstring

>  insert_function_docstring (lines:List[str], def_line_idx:int, indent:str)

*Insert a TODO docstring after the function signature*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>lines</td>
<td>List</td>
<td>Fixed function lines</td>
</tr>
<tr>
<td>def_line_idx</td>
<td>int</td>
<td>Index of function definition line</td>
</tr>
<tr>
<td>indent</td>
<td>str</td>
<td>Base indentation for the function</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>List</strong></td>
<td><strong>Lines with docstring inserted</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### fix_single_line_function

>  fix_single_line_function (lines:List[str], def_line_idx:int,
>                                result:cjm_nbdev_docments.core.DocmentsCheckRes
>                                ult)

*Fix a single-line function signature by converting to multi-line with
parameter comments*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>lines</td>
<td>List</td>
<td>All source lines</td>
</tr>
<tr>
<td>def_line_idx</td>
<td>int</td>
<td>Index of function definition line</td>
</tr>
<tr>
<td>result</td>
<td>DocmentsCheckResult</td>
<td>Check result with missing params info</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>List</strong></td>
<td><strong>Fixed lines for the function</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### fix_multi_line_function

>  fix_multi_line_function (lines:List[str], def_line_idx:int,
>                               sig_end_idx:int, result:cjm_nbdev_docments.core.
>                               DocmentsCheckResult)

*Fix a multi-line function signature by adding parameter comments*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>lines</td>
<td>List</td>
<td>All source lines</td>
</tr>
<tr>
<td>def_line_idx</td>
<td>int</td>
<td>Start of function definition</td>
</tr>
<tr>
<td>sig_end_idx</td>
<td>int</td>
<td>End of function signature</td>
</tr>
<tr>
<td>result</td>
<td>DocmentsCheckResult</td>
<td>Check result with missing params info</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>List</strong></td>
<td><strong>Fixed lines for the function</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### generate_fixed_source

>  generate_fixed_source
>                             (result:cjm_nbdev_docments.core.DocmentsCheckResul
>                             t)

*Generate fixed source code for a non-compliant function or class*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>result</td>
<td>DocmentsCheckResult</td>
<td>Check result with non-compliant function</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>str</strong></td>
<td><strong>Fixed source code with placeholder
documentation</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### fix_notebook

>  fix_notebook (nb_path:pathlib.Path, dry_run:bool=False)

*Fix non-compliant functions in a notebook by adding placeholder
documentation*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>nb_path</td>
<td>Path</td>
<td></td>
<td>Path to notebook to fix</td>
</tr>
<tr>
<td>dry_run</td>
<td>bool</td>
<td>False</td>
<td>If True, show changes without saving</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>Dict</strong></td>
<td></td>
<td><strong>Summary of changes made</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### DocstringInfo

>  DocstringInfo (description:str, params:Dict[str,str],
>                     returns:Optional[str], docstring_type:str)

*Information extracted from a docstring*

------------------------------------------------------------------------

### detect_docstring_style

>  detect_docstring_style (docstring:str)

*Detect the style of a docstring*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>docstring</td>
<td>str</td>
<td>Docstring text to analyze</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>str</strong></td>
<td><strong>Detected style: ‚Äògoogle‚Äô, ‚Äònumpy‚Äô, ‚Äòsphinx‚Äô, ‚Äòdocments‚Äô, or
‚Äòunknown‚Äô</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### parse_google_docstring

>  parse_google_docstring (docstring:str)

*Parse a Google-style docstring*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>docstring</td>
<td>str</td>
<td>Google-style docstring text</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>DocstringInfo</strong></td>
<td><strong>Parsed docstring information</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### parse_numpy_docstring

>  parse_numpy_docstring (docstring:str)

*Parse a NumPy-style docstring*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>docstring</td>
<td>str</td>
<td>NumPy-style docstring text</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>DocstringInfo</strong></td>
<td><strong>Parsed docstring information</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### parse_sphinx_docstring

>  parse_sphinx_docstring (docstring:str)

*Parse a Sphinx-style docstring*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>docstring</td>
<td>str</td>
<td>Sphinx-style docstring text</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>DocstringInfo</strong></td>
<td><strong>Parsed docstring information</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### extract_docstring_info

>  extract_docstring_info (source:str, name:str)

*Extract docstring information from function source code*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>source</td>
<td>str</td>
<td>Function source code</td>
</tr>
<tr>
<td>name</td>
<td>str</td>
<td>Function name</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>Optional</strong></td>
<td><strong>Extracted docstring information or None</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### convert_to_docments_format

>  convert_to_docments_format (source:str,
>                                  docstring_info:__main__.DocstringInfo, result
>                                  :cjm_nbdev_docments.core.DocmentsCheckResult)

*Convert function source to docments format using extracted docstring
info*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>source</td>
<td>str</td>
<td>Original function source code</td>
</tr>
<tr>
<td>docstring_info</td>
<td>DocstringInfo</td>
<td>Extracted docstring information</td>
</tr>
<tr>
<td>result</td>
<td>DocmentsCheckResult</td>
<td>Check result with missing params info</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>str</strong></td>
<td><strong>Converted source code in docments format</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### convert_single_line_to_docments

>  convert_single_line_to_docments (sig_line:str,
>                                       docstring_info:__main__.DocstringInfo, r
>                                       esult:cjm_nbdev_docments.core.DocmentsCh
>                                       eckResult)

*Convert single-line function signature to multi-line docments format*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>sig_line</td>
<td>str</td>
<td>Single-line function signature</td>
</tr>
<tr>
<td>docstring_info</td>
<td>DocstringInfo</td>
<td>Extracted docstring information</td>
</tr>
<tr>
<td>result</td>
<td>DocmentsCheckResult</td>
<td>Check result with missing params info</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>List</strong></td>
<td><strong>Multi-line signature with docments comments</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### convert_multiline_to_docments

>  convert_multiline_to_docments (sig_lines:List[str],
>                                     docstring_info:__main__.DocstringInfo, res
>                                     ult:cjm_nbdev_docments.core.DocmentsCheckR
>                                     esult)

*Convert multi-line function signature to docments format*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>sig_lines</td>
<td>List</td>
<td>Multi-line function signature</td>
</tr>
<tr>
<td>docstring_info</td>
<td>DocstringInfo</td>
<td>Extracted docstring information</td>
</tr>
<tr>
<td>result</td>
<td>DocmentsCheckResult</td>
<td>Check result with missing params info</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>List</strong></td>
<td><strong>Multi-line signature with docments comments</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### replace_docstring_in_body

>  replace_docstring_in_body (body_lines:List[str], description:str,
>                                 def_line:str)

*Replace the docstring in function body with a simple description*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>body_lines</td>
<td>List</td>
<td>Function body lines</td>
</tr>
<tr>
<td>description</td>
<td>str</td>
<td>New description to use</td>
</tr>
<tr>
<td>def_line</td>
<td>str</td>
<td>Function definition line for indentation</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>List</strong></td>
<td><strong>Modified body lines</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### generate_fixed_source_with_conversion

>  generate_fixed_source_with_conversion
>                                             (result:cjm_nbdev_docments.core.Do
>                                             cmentsCheckResult)

*Generate fixed source code, converting existing docstrings to docments
format if possible*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>result</td>
<td>DocmentsCheckResult</td>
<td>Check result with non-compliant function</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>str</strong></td>
<td><strong>Fixed source code with converted documentation</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

### fix_notebook_with_conversion

>  fix_notebook_with_conversion (nb_path:pathlib.Path, dry_run:bool=False,
>                                    convert_docstrings:bool=True)

*Fix non-compliant functions in a notebook, optionally converting
docstrings to docments format*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>nb_path</td>
<td>Path</td>
<td></td>
<td>Path to notebook to fix</td>
</tr>
<tr>
<td>dry_run</td>
<td>bool</td>
<td>False</td>
<td>If True, show changes without saving</td>
</tr>
<tr>
<td>convert_docstrings</td>
<td>bool</td>
<td>True</td>
<td>If True, convert existing docstrings to docments format</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>Dict</strong></td>
<td></td>
<td><strong>Summary of changes made</strong></td>
</tr>
</tbody>
</table>

### Testing

``` python
def test_docstring_detection_and_parsing():
    """Test docstring style detection and parsing for all supported formats"""
    print("üß™ Testing Docstring Detection and Parsing")
    print("=" * 50)
    
    # Test docstrings for different styles
    test_docstrings = [
        # Google style
        ('google', '''"""Calculate the sum of two numbers.
        
        Args:
            x (int): The first number to add
            y (int): The second number to add
            
        Returns:
            int: The sum of x and y
        """'''),
        
        # NumPy style  
        ('numpy', '''"""Calculate the sum of two numbers.
        
        Parameters
        ----------
        x : int
            The first number to add
        y : int  
            The second number to add
            
        Returns
        -------
        int
            The sum of x and y
        """'''),
        
        # Sphinx style
        ('sphinx', '''"""Calculate the sum of two numbers.
        
        :param x: The first number to add
        :param y: The second number to add
        :returns: The sum of x and y
        """'''),
        
        # Unknown style
        ('unknown', '''"""Just a simple description without structured parameters."""''')
    ]
    
    # Test detection
    print("üìã Style Detection Results:")
    for expected_style, docstring in test_docstrings:
        detected_style = detect_docstring_style(docstring)
        status = "‚úÖ" if detected_style == expected_style else "‚ùå"
        print(f"{status} {expected_style.title()}: {detected_style}")
    
    # Test parsing for structured formats
    print("\nüìñ Parsing Results:")
    for style_name, docstring in test_docstrings[:3]:  # Skip unknown style
        if style_name == 'google':
            parsed = parse_google_docstring(docstring)
        elif style_name == 'numpy':
            parsed = parse_numpy_docstring(docstring)
        elif style_name == 'sphinx':
            parsed = parse_sphinx_docstring(docstring)
        
        print(f"\n{style_name.title()} parsing:")
        print(f"  Description: {parsed.description}")
        print(f"  Parameters: {list(parsed.params.keys())}")
        print(f"  Returns: {'Yes' if parsed.returns else 'No'}")
    
    print("\n‚úÖ Docstring detection and parsing tests completed")

# Run test
test_docstring_detection_and_parsing()
```

    üß™ Testing Docstring Detection and Parsing
    ==================================================
    üìã Style Detection Results:
    ‚úÖ Google: google
    ‚úÖ Numpy: numpy
    ‚úÖ Sphinx: sphinx
    ‚úÖ Unknown: unknown

    üìñ Parsing Results:

    Google parsing:
      Description: Calculate the sum of two numbers.
      Parameters: ['x', 'y']
      Returns: Yes

    Numpy parsing:
      Description: Calculate the sum of two numbers.
      Parameters: ['x', 'y']
      Returns: Yes

    Sphinx parsing:
      Description: """Calculate the sum of two numbers. """
      Parameters: ['x', 'y']
      Returns: Yes

    ‚úÖ Docstring detection and parsing tests completed

``` python
def test_function_fixing():
    """Test basic function fixing for various scenarios"""
    print("\nüîß Testing Function Fixing")
    print("=" * 50)
    
    # Test cases with different compliance issues
    test_cases = [
        {
            'name': 'missing_all_docs',
            'source': '''def bad_function(x, y, z=10):
    result = x + y + z
    return result''',
            'args': [
                {'name': 'x', 'annotation': None},
                {'name': 'y', 'annotation': None},
                {'name': 'z', 'annotation': None}
            ],
            'returns': None,
            'description': 'Missing all documentation and type hints'
        },
        {
            'name': 'typed_function',
            'source': '''def typed_function(name: str, age: int) -> str:
    return f"{name} is {age} years old"''',
            'args': [
                {'name': 'name', 'annotation': 'str'},
                {'name': 'age', 'annotation': 'int'}
            ],
            'returns': 'str',
            'description': 'Has type hints but missing parameter documentation'
        },
        {
            'name': 'partially_documented',
            'source': '''def get_export_cells(
    nb_path: Path,  # Path to the notebook file
    fake_test_path: Path 
) -> List[Dict[str, Any]]:  # List of cells with export directives
    """Extract all code cells from a notebook that have export directives"""
    nb = read_nb(nb_path)
    return []''',
            'args': [
                {'name': 'nb_path', 'annotation': 'Path'},
                {'name': 'fake_test_path', 'annotation': 'Path'}
            ],
            'returns': 'List[Dict[str, Any]]',
            'description': 'Partially documented - missing one parameter doc'
        }
    ]
    
    for test_case in test_cases:
        print(f"\nüìù Testing: {test_case['description']}")
        print(f"Function: {test_case['name']}")

        print(f"\nSource:\n{test_case['source']}\n")
        
        # Create test definition
        test_def = {
            'name': test_case['name'],
            'type': 'FunctionDef',
            'source': test_case['source'],
            'notebook': 'test.ipynb',
            'args': test_case['args'],
            'returns': test_case['returns']
        }
        
        # Check compliance
        result = check_definition(test_def)
        print(f"Has docstring: {result.has_docstring}")
        print(f"Is compliant: {result.is_compliant}")
        if not result.is_compliant:
            print(f"Missing: {result.missing_params}")
            
            # Apply fix
            fixed_source = generate_fixed_source(result)
            print(f"\nFixed Source:\n{fixed_source}\n")
    
    print("\n‚úÖ Function fixing tests completed")

# Run test
test_function_fixing()
```


    üîß Testing Function Fixing
    ==================================================

    üìù Testing: Missing all documentation and type hints
    Function: missing_all_docs

    Source:
    def bad_function(x, y, z=10):
        result = x + y + z
        return result

    Has docstring: False
    Is compliant: False
    Missing: ['x', 'y', 'z']

    Fixed Source:
    def bad_function(
        x,  # TODO: Add type hint and description
        y,  # TODO: Add type hint and description
        z=10  # TODO: Add type hint and description
    ):
        """TODO: Add function description"""
        result = x + y + z
        return result


    üìù Testing: Has type hints but missing parameter documentation
    Function: typed_function

    Source:
    def typed_function(name: str, age: int) -> str:
        return f"{name} is {age} years old"

    Has docstring: False
    Is compliant: False
    Missing: ['name', 'age', 'return']

    Fixed Source:
    def typed_function(
        name: str,  # TODO: Add description
        age: int  # TODO: Add description
    ) -> str:  # TODO: Add return description
        """TODO: Add function description"""
        return f"{name} is {age} years old"


    üìù Testing: Partially documented - missing one parameter doc
    Function: partially_documented

    Source:
    def get_export_cells(
        nb_path: Path,  # Path to the notebook file
        fake_test_path: Path 
    ) -> List[Dict[str, Any]]:  # List of cells with export directives
        """Extract all code cells from a notebook that have export directives"""
        nb = read_nb(nb_path)
        return []

    Has docstring: False
    Is compliant: False
    Missing: ['fake_test_path']

    Fixed Source:
    def get_export_cells(
        nb_path: Path,  # Path to the notebook file
        fake_test_path: Path   # TODO: Add description
    ) -> List[Dict[str, Any]]:  # List of cells with export directives
        """Extract all code cells from a notebook that have export directives"""
        nb = read_nb(nb_path)
        return []


    ‚úÖ Function fixing tests completed

``` python
def test_docstring_conversion():
    """Test conversion from various docstring formats to docments style"""
    print("\nüîÑ Testing Docstring Conversion")
    print("=" * 50)
    
    # Test functions with different docstring formats
    test_functions = [
        {
            'name': 'google_example',
            'source': '''def google_example(name: str, age: int, active: bool = True) -> str:
    """Generate a user profile string.
    
    Args:
        name (str): The user's full name
        age (int): The user's age in years
        active (bool): Whether the user is currently active
        
    Returns:
        str: A formatted profile string
    """
    return f"{name} ({age}) - {'Active' if active else 'Inactive'}"''',
            'args': [
                {'name': 'name', 'annotation': 'str'},
                {'name': 'age', 'annotation': 'int'},
                {'name': 'active', 'annotation': 'bool'}
            ],
            'returns': 'str',
            'style': 'Google'
        },
        {
            'name': 'numpy_example',
            'source': '''def numpy_example(data: list, threshold: float = 0.5) -> dict:
    """Process data based on threshold.
    
    Parameters
    ----------
    data : list
        Input data to process
    threshold : float
        Minimum threshold value
        
    Returns
    -------
    dict
        Processing results with statistics
    """
    return {'processed': len(data), 'threshold': threshold}''',
            'args': [
                {'name': 'data', 'annotation': 'list'},
                {'name': 'threshold', 'annotation': 'float'}
            ],
            'returns': 'dict',
            'style': 'NumPy'
        }
    ]
    
    for func_info in test_functions:
        print(f"\nüìù Testing {func_info['style']} Style Conversion")
        print(f"Function: {func_info['name']}")

        print(f"\nSource:\n{func_info['source']}\n")
        
        # Create test definition
        test_def = {
            'name': func_info['name'],
            'type': 'FunctionDef',
            'source': func_info['source'],
            'notebook': 'test.ipynb',
            'args': func_info['args'],
            'returns': func_info['returns']
        }
        
        # Check original compliance
        result = check_definition(test_def)
        
        
        # Extract and verify docstring info
        docstring_info = extract_docstring_info(result.source, result.name)
        if docstring_info:
            print(f"Docstring type: {docstring_info.docstring_type}")
            print(f"Parameters found: {list(docstring_info.params.keys())}")
            print(f"Return info: {'Yes' if docstring_info.returns else 'No'}")
        
        # Convert to docments format
        converted = generate_fixed_source_with_conversion(result)
        print(f"\nConverted Source:\n{converted}\n")
        
        # Verify converted version is compliant
        test_def_converted = test_def.copy()
        test_def_converted['source'] = converted
        result_converted = check_definition(test_def_converted)
    
    print("\n‚úÖ Docstring conversion tests completed")

# Run test
test_docstring_conversion()
```


    üîÑ Testing Docstring Conversion
    ==================================================

    üìù Testing Google Style Conversion
    Function: google_example

    Source:
    def google_example(name: str, age: int, active: bool = True) -> str:
        """Generate a user profile string.

        Args:
            name (str): The user's full name
            age (int): The user's age in years
            active (bool): Whether the user is currently active

        Returns:
            str: A formatted profile string
        """
        return f"{name} ({age}) - {'Active' if active else 'Inactive'}"

    Docstring type: google
    Parameters found: ['name', 'age', 'active']
    Return info: Yes

    Converted Source:
    def google_example(
        name: str,  # The user's full name
        age: int,  # The user's age in years
        active: bool = True  # Whether the user is currently active
    ) -> str:  # str: A formatted profile string
        """Generate a user profile string."""
        return f"{name} ({age}) - {'Active' if active else 'Inactive'}"


    üìù Testing NumPy Style Conversion
    Function: numpy_example

    Source:
    def numpy_example(data: list, threshold: float = 0.5) -> dict:
        """Process data based on threshold.

        Parameters
        ----------
        data : list
            Input data to process
        threshold : float
            Minimum threshold value

        Returns
        -------
        dict
            Processing results with statistics
        """
        return {'processed': len(data), 'threshold': threshold}

    Docstring type: numpy
    Parameters found: ['data', 'threshold']
    Return info: Yes

    Converted Source:
    def numpy_example(
        data: list,  # Input data to process
        threshold: float = 0.5  # Minimum threshold value
    ) -> dict:  # dict Processing results with statistics
        """Process data based on threshold."""
        return {'processed': len(data), 'threshold': threshold}


    ‚úÖ Docstring conversion tests completed
